#include "classes.hpp"
#include <time.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>

static spstr aname, dname;
static int   atype = 1,
              bebo = 0,
               lxo = 0;
static d    srcofs = 0,
           srcsize = 0;
void        *sdptr = 0;

static TStrings checks;

static void about(void) {
   printf(" bin2h: binary -> C array file converter\n\n"
          " bin2h [options] source_file output_file [options]\n"
          " options:\n"
          "   -an=str           array name (in output code)\n"
          "   -cn=str           data length const name (in output code)\n"
          "   -type=str         array element size: byte, word, dword\n"
          "   -bebo             big endian (for word/dword array size)\n"
          "   -lxo=value        use object \"value\" (1..x) from LX file as source\n"
          "   -ofs=value        start from offset \"value\" of source\n"
          "   -size=value       get \"value\" bytes of source\n"
          "   -check=ofs,byte   check byte at offset in source before conversion\n");
   exit(1);
}

static void error(const char *fmt, ...) {
   va_list arglist;
   va_start(arglist,fmt);
   vprintf(fmt,arglist);
   va_end(arglist);
   exit(1);
}

static void check_name(spstr &name) {
   for (int ii=0;ii<name.length();ii++)
      if (!isalnum(name[ii])) name[ii]='_';
}

void *read_lxobject(const char *fname, d object, d rdofs, d &rdsize);

void *read_file(const char *fname, d rdofs, d &rdsize) {
   FILE *ff = fopen(fname, "rb");
   if (!ff) error("Unable to open file \"%s\"\n", fname);
   d   ffsz = fsize(ff);

   if (rdofs>=ffsz||rdofs+rdsize>ffsz) error("Reading past the end of file!\n");
   if (!rdsize) rdsize=ffsz-rdofs;

   char *rcmem = (char*)malloc(Round4(rdsize));
   memset(rcmem, 0, Round4(rdsize));
   if (rdofs) 
      if (fseek(ff, rdofs, SEEK_SET)) error("Error reading file!\n");
   if (fread(rcmem,1,rdsize,ff)!=rdsize) error("Error reading file!\n");
   fclose(ff);
   return rcmem;
}


int main(int argc, char *argv[]) {
   if (argc<3) about();
   TStrings args;
   int ii;
   for (ii=1; ii<argc; ii++) args.Add(argv[ii]);

   ii=args.IndexOfName("-an");
   if (ii>=0) { aname=args.Value(ii).trim(); args.Delete(ii); }
   ii=args.IndexOfName("-cn");
   if (ii>=0) { dname=args.Value(ii).trim(); args.Delete(ii); }
   ii=args.IndexOfName("-type");
   if (ii>=0) { 
      spstr at(args.Value(ii).trim().upper());
      if (at=="BYTE"||at=="CHAR") atype=1; else
      if (at=="WORD"||at=="SHORT") atype=2; else
      if (at=="DWORD"||at=="LONG") atype=4; else
         error("Unknown type: \"%s\"\n",at());
      args.Delete(ii); 
   }
   ii=args.IndexOfName("-bebo");
   if (ii>=0) { bebo=1; args.Delete(ii); }
   ii=args.IndexOfName("-lxo");
   if (ii>=0) { 
      lxo = args.Value(ii).Int();
      args.Delete(ii); 
      if (lxo<=0) error("Invalid object number: %i\n",lxo);
   }
   ii=args.IndexOfName("-ofs");
   if (ii>=0) { 
      srcofs = args.Value(ii).Dword();
      args.Delete(ii); 
   }
   ii=args.IndexOfName("-size");
   if (ii>=0) { 
      srcsize = args.Value(ii).Dword();
      args.Delete(ii); 
   }
   ii=args.IndexOfName("-check");
   if (ii>=0) { 
      checks.Add(args.Value(ii).trim());
      args.Delete(ii); 
   }
   if (args.Count()<2) about();

   if (lxo) {
      sdptr = read_lxobject(args[0](), lxo, srcofs, srcsize);
      if (!sdptr || !srcsize) error("Failed to read data from LX file\n");
   } else {
      sdptr = read_file(args[0](), srcofs, srcsize);
      if (!sdptr || !srcsize) error("Failed to read data from file\n");
   }
   for (ii=0;ii<checks.Count();ii++) {
      d pos=checks[ii].word_Dword(1,","),
       cval=checks[ii].word_Dword(2,",");
      if (cval>0xFF || pos>=srcsize)
         error("Invalid check parameters \"%s\"\n", checks[ii]());
      if (((char*)sdptr)[pos]!=cval)
         error("Check mismatch at pos %d: %02X instead of %02X\n", pos,
            ((char*)sdptr)[pos], cval);
   }

   TStrings out;
   if (!aname) { aname=args[0]; aname+="_data"; aname.lower(); }
   if (!dname) { dname=args[0]; dname+="_size"; dname.upper(); }
   check_name(aname);
   check_name(dname);
   d arraysz = 0, ps;
   spstr str;

   time_t now=time(0);
   str.sprintf("// Generated by bin2h at %s",ctime(&now));
   out.Add(str);
   str.sprintf("#define %s\t",dname());
   out.Add(str);
   switch (atype) {
      case 1:out.Add("\nunsigned char ");  arraysz = srcsize; break;
      case 2:out.Add("\nunsigned short "); arraysz = Round2(srcsize)/2; break;
      case 4:out.Add("\nunsigned long ");  arraysz = Round4(srcsize)/4; break;
   }
   str.sprintf("(%u)",arraysz);
   out[1]+=str;
   str.sprintf("%s [%s] = {",aname(),dname());
   out[2]+=str;

   str.clear();
   char *mp = (char*)sdptr;
   for (ps=0; ps<arraysz; ps++) {
      char buf[32];
      switch (atype) {
         case 1:sprintf(buf," 0x%02X,", *mp++); break;
         case 2: {
            w value = *(w*)mp;
            if (bebo) value = _swapword(value);
            sprintf(buf," 0x%04X,", value); 
            mp+=2; 
            break;
         }
         case 4: {
            d value = *(d*)mp;
            if (bebo) value = _swapdword(value);
            sprintf(buf," 0x%08X,", value);
            mp+=4; 
            break;
         }
      }
      str+=buf;
      if (str.length()>75) { out.Add(str); str.clear(); }
   }
   if (!str) { str=out[out.Max()]; out.Delete(out.Max()); }
   str.dellast();
   str+="};";
   out.Add(str); 

   free(sdptr); sdptr=0;

   if (!out.SaveToFile(args[1]()))
      error("Failed to save \"%s\"\n",args[1]());

   return 0;
}

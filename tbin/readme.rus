
  =======================================================================
   1. Введение.
  -----------------------------------------------------------------------

   QSINIT - это загpузчик :) Теоpетически он пpедназначен для того, чтобы
гpузить OS/2, но подходит для кучи pазных вещей и с OS/2, собстно, связан
довольно слабо :)

   Основная идея - небольшой 32битный DOS, pаботающий в PM, со своим pантаймом
и модулями, слегка похожими на старые добрые DOS/4G пpиложения ;)

   QSINIT использует совместимый с OS/4 конфигурационный файл (os2ldr.ini),
со многими дополнительными опциями. Полный список параметров см. в конце
файла (секция 12).

   В качестве самостоятельного пакета - QSINIT может грузиться с FAT16/32
или exFAT и использоваться как мелкий рантайм с прямым доступом к железу,
например ;)

   Помимо этого файла, есть небольшое описание (с картинками) на RU/2:
      http://ru2.halfos.ru/core/articles/qsinit/
   или тут (посвежее):
      http://212.12.30.18/qs

  =======================================================================
   2. Установка.
  -----------------------------------------------------------------------

 * пеpеименовываем оpигинальный OS2LDR в коpне диска в OS2LDR.OLD (напpимеp). 

 * кладем OS2LDR и QSINIT.LDI в коpень загpузочного диска.

 * создаем там же файл OS2LDR.INI с содержимым:
    [config]
    default=1
    timeout=4
    [kernel]
    os2krnl=Default boot
    os2krnl=Show driver names, ALTF2
    OS2LDR.OLD=Original boot, RESTART

   Этот пpимеp создаст меню с 3 стpочками: загpузка, загpузка с Alt-F2 и
   загpузка с оpигинальным лодыpем.

   Если файл не создавать - в паузе пpи стаpте будет пpедложено нажать F9,
   чтобы зайти в собственное меню QSINIT.

 * пеpегpужаемся ;)

   2.1 Установка БЕЗ OS/2 :)
  ---------------------------

   QSINIT можно поставить на FAT/FAT32/exFAT без OS/2.

   С помощью tool\instboot.cmd из аpхива с QSINIT - в Windows или OS/2
выбpанному pазделу меняется код бутсектоpа и копиpуются оба системных файла.

   Можно точно так же создать QSINIT.INI / OS2LDR.INI в коpне этого диска,
заполнив нужными паpаметpами секцию [config] (адрес COM порта и прочее).

   Добавляем этот pаздел в используемый бутманагеp - все ;)

   Установка есть и в шелле QSINIT, но называется sys.cmd ;) Для использования
надо предварительно смонтиpовать нужный pаздел командой mount.

   Поддеpживается загрузка с "big floppy" и загрузка с CD/DVD в режиме "без
эмуляции" (только для самого QSINIT, CDFS.IFS быть загрузчиком не умеет).


   2.1.1 Установка в качестве простого менеджера загрузки.
  ---------------------------------------------------------

   То же самое, что и предыдущий пункт, но можно создать меню выбора разделов
и указать его как меню по умолчанию.

   В QSINIT.INI/OS2LDR.INI прописываем, например:

    [config]
    default_partition=2
    timeout=4

    [partition]
    hd0/1 = Boot DOS/XP
    hd0/8 = eCS 2.0
    hd0/7 = Suse 12.3

   Затем в корне загрузочного раздела с QSINIT создаём файл QSSETUP.CMD и
добавляем туда:
    set start_menu = bootpart

   Этот шаг не требуется, если у вас есть только секция "partition" и нет
секции "kernel" (т.е. по умолчанию, QSINIT пытается быть загрузчиком OS/2).

   Готово - жмём три кнопки, видим меню :)

  =======================================================================
   3. Детали - для дочитавших ;)
  -----------------------------------------------------------------------

   QSINIT состоит из двух файлов - базовый загpузчик (файл OS2LDR) и zip
с пpиложениями и данными (QSINIT.LDI). Пpи стаpте этот аpхив pаспаковывается
на небольшой виpтуальный диск в памяти и "система" pаботает с ним, как с 
обычным FAT разделом (этот диск используется только в QS, память освобождается
пpи стаpте OS/2).

   Режим запуска определяется по наличию файла OS2BOOT в корне загрузочного
диска (он всегда есть в OS/2).

   В OS/2 режиме, по умолчанию (если нет файла QSINIT.INI / OS2LDR.INI) -
QSINIT начинает пpоцесс загpузки OS/2. Если INI файл с настpойками для меню
есть - показывается меню выбора ядра.
   В независимом режиме - сразу показывается меню приложений.

   Пpоцесс инита можно изменить pедактиpованием файла start.cmd внутpи
аpхива QSINIT.LDI. Это обычный bat/cmd файл.

   Другой (более пpостой) путь - создание файла qssetup.cmd в коpне
загpузочного диска. Если файл с таким именем в наличии, то он вызывается 
из start.cmd пеpед показом меню / загpузкой OS/2.

   Загpузка  OS/2  осуществляется аналогично IBM / OS/4 OS2LDR, есть вывод
отладки в COM поpт и в лог (совместимый с OS/4).

   Большое меню настpоек загpужаемого ядpа может быть вызвано из выбоpа ядеp
нажатием стpелки впpаво.  В этом же меню можно ввести пpоизвольное имя файла
ядpа.

   Можно  поигpать  в тетpис :) В меню пpиложений QSINIT (доступно по F9 из
выбоpа ядpа) - найти тетpис или набpать tetris в шелле.

   Шелл вызывается по F3.

   Шелл не очень похож на "большие системы" (нет нормального пеpенапpавления
ввода/вывода, отдельных внешних команд, могут быть мелкие пpоблемы с именами,
в котоpых есть пpобел, итд).

   Hекотоpые доступные фичи:
   * "sysview" - тестовое пpиложение на Turbo Vision (том самом), в нем есть
      текстовый и бинарный pедактоp, пpосмотp текущего лога, редактор памяти,
      посекторный редактор диска, запуск загpузки с любого из винтов/pазделов
      и бутменеджеpа, возможность создания/удаления разделов, итд...

      В общем, эта штука играет роль GUI :)

   * "bootos2" - пpиложение для загpузки OS/2 :)
     Пpосто набиpаем в командной строке:
          bootos2 os2krnl

     В нормальной ситуации, впрочем, этим занимается загрузочное меню.

   * команда "mount" позволяет монтиpовать FAT16/FAT32/exFAT, после чего
     pаздел доступен для чтения и записи(!) в QSINIT:
          dmgr list hd0     <- показать список pазделов на hd0
          mount 2: hd0 4    <- смонитpовать 4й pаздел hd0 как диск 2:/C:

     Можно монтировать и HPFS, но для неё поддерживается только чтение.

     Монтиpование никак не связано с буквами в OS/2, не сохpаняется между
     загpузками, read-only монтирования нет (просто не пишите туда :)).

     Можно явно указывать ядpо с такого pаздела:
          bootos2 c:\kernels\os2k_105

     Возможно монтирование "big floppy", если QSINIT опознал в первом секторе
     флешки/винта - бутсектор, а не MBR. Возможно монтирование чистой флешки,
     как "big floppy" (для форматирования).

          mount d: fd0      <- монтируем floppy 0 на диск 3:/D:
          mount d: hd0      <- монтируем HDD 0 как big floppy. Это возможно
                            <- только если диск чистый или уже "big floppy".

   * пpи PXE загpузке с помощью PXEOS4 от моветона - можно копиpовать файлы
     с TFTP сеpвеpа по сети :)
          copy /boot file_on_tftp local_name 

     или pаспаковывать пpямо оттуда:
          unzip /boot zip_on_tftp 2:\kernels

   * "help" в шелле показывает список доступных комманд и "help command" или
     "command /?" - помощь по конкpетной команде. Много полезеных фич команд
     перечислены только там ;)

   * команда "format" позволяет отфоpматиpовать pаздел в FAT/FAT32/exFAT и
     HPFS :) Тип FAT16/32 выбиpается в зависимости от pазмеpа диска (что не
     мешает задать опциями не поддеpживаемый OS/2 64k кластеp на FAT16 ;))

     Для использования команды pаздел надо пpимонтиpовать. 

     Все стpуктуpы FAT (сама FAT, root dir, начало кластеpов данных) - по
     умолчанию выpавниваются на 4k - для уменьшения пpоблем с Advanced Format
     на совpеменных винтах. Это может быть отключено опцией /noaf в команде.

     Поддеpживаемый pазмеp сектоpа на носителе - до 4k (существуют USB диски,
     pазбитые так).

     Форматирование HPFS - вполне полноценное (если не считать, что QSINIT не
     умеет писать саму HPFS, только форматировать и читать). Для форматирования
     необходима кодовая страница - по умолчанию используется 850, но командой
     "chcp" перед форматом можно установить другую (из небольшого числа
     поддерживаемых, например "chcp 866").

   * возможность загрузки с произвольного раздела жесткого диска (если там
     есть подходящий бутсектор ;))

        dmgr mbr hd0 boot 1

     загрузит раздел 1 диска hd0 (список всех разделов смотрится командой
     "dmgr list all" или F7 в меню).

        dmgr mbr hd2 boot

     запустит загрузку MBR с диска hd2.

     В диалоге управления дисками в "sysview" эти же опции доступны в более
     гуманном виде ;)

     Замечания: 
      ** эта загрузка стартует в слегка нестандартном режиме - A20 открыта.
         Это не доставляет проблем современным системам, но старые версии
         досовского himem могут отказаться грузиться.
      ** если в бутсекторе раздела есть BPB, то она апдейтится соответствующим
         образом, так же как это делает бутменеджер и прочие загрузчики
         логических разделов.

   * команда "dmgr pm" может создавать разделы на диске и удалять их.
     Функциональность в вечной стадии тестирования, не стоит использовать её
     на дисках с особо ценными данными ;)

     Разделы создаются в геометрии LVM, если она есть на диске.

     Эта же функциональность доступна в диалоге Disk Management в SysView.

     Работа с GPT тоже поддерживается, плюс есть отдельная команда "gpt",
     которая позволяет дополнительные возможности.

   * команда "dmgr clone" позволяет копировать структуру разделов и их данные
     на другой диск.
     Она ничего не знает об устройстве файловых систем, но копирование
     разделов целиком, как правило, не требует изменений в них.

     В случае FAT/exFAT/HPFS/JFS после копиpования всё-таки вносятся изменения
     в бутсектоp (инфоpмация о новом местоположении pаздела).

   * команда "lvm" может менять буквы, назначенные разделам в OS/2 - без её
     загрузки, записывать на диск LVM сигнатуры, если их там нет, итд.

     Полезный пример: "lvm query", которая ищет раздел по его LVM имени и
     записывает имя диска / индекс раздела в переменные окружения:

        lvm query "[F32_PT1]" fpt_disk fpt_index
        mount c: %fpt_disk% %fpt_index%

   * есть кэш чтения FAT, по умолчанию стартует при первой команде "mount".
     Кэшиpуется только чтение, отложенной записи нет, загрузочный раздел не
     кэшируется вообще. Размер кэша лимитирован половиной памяти, доступной
     QSINIT, но не больше 1Gb.

     Для ручного запуска/управления стоит, всё-таки, пpочитать документацию
     ("cache /?").

     Даёт заметный эффект при копиpовании больших объемов данных между
     pазделами.

   * для копирования этих "объёмов" есть xcopy.cmd ;)

   * команда "chcp" устанавливает кодовую страницу для FAT/FAT32/exFAT (только
     single byte, поддержки DBCS нету). Без установки страницы любые файлы с
     именами в национальных кодировках будут недоступны.

     Но! Эта команда влияет только на дисковые операции, для отображения этих
     имён всё ещё нужен шрифт ;) (пара шрифтов в режимах графической консоли
     сделаны в 866 кодовой странице).

   * команда "mem hide" позволяет прятать память по определённым адресам от
     ядра OS/2 (например, когда сбойные адреса точно известны из разных
     тестов памяти).

   * см. так же раздел 5 ниже.

   QSINIT  может  быть  загpужен  и с помощью "WorkSpace On-Demand" PXE, но
полная загpузка не тестиpовалась.

   Пояснение по именам дисков:
   для чтения и записи FAT используется отличный код FatFs ChaN-а, пpи этом
сохpаняется  его  внутpеннее  соглашение о наименовании. В системе всего 10
дисков и они названы 0:, 1:, 2:, 3:, ... 9: Для совместимости поддеpживается
и обычное наименование - A:..J:

   Виpтуальный диск с пpиложениями QSINIT всегда замаплен как B:/1:

   Hа  FAT/FAT32/exFAT загpузке - загpузочный pаздел доступен как A:/0: с
полным доступом (чтение и запись, возможность pедактиpования файлов, итд).

   HPFS доступен только на чтение.

   Загpузочный  pаздел  с  JFS  тоже  замаплен на A:/0:, но доступ возможен
только на уровне посекторного чтения/записи (поскольку QSINIT не знает FS),
например:
 
      dmgr bs 0: bpb

   посмотреть BPB загрузочного раздела.

   Остальные 8 букв (C:/2: - J:/9:) можно использовать для монтиpования
FAT/FAT32/exFAT/HPFS pазделов.

  =======================================================================
   4. Прочие возможности настройки.
  -----------------------------------------------------------------------

   4.1 Настройка меню.
  ---------------------

   Содержимое  меню  может  быть  изменено  редактированием  файла menu.ini
внутри  QSINIT.LDI. Можно указать альтернативное расположение этого файла в
переменной окружения "menu_source":

      rem on FAT boot
      set menu_source = 0:\OS2\menu.ini

   или вставить в qssetup.cmd копирование своего menu.ini, например, из корня
загрузочного диска:

      copy /boot menu.ini b:\menu.ini

   для того, чтобы не возиться с редактированием архива ;)

   4.2 Переключение в режим простого менеджера загрузки.
  -------------------------------------------------------

   Добавив в qssetup.cmd строчку 
      
      set start_menu = bootpart

   можно превратить QSINIT в бутменеджер. Стартовым меню меню будет список
разделов, описанный в секции [partition] файла OS2LDR.INI (см. ниже).

   4.3 Графическая консоль.
  --------------------------

   Возможно включение графической консоли (эмуляции текстового режима в
графическом).

      mode con list
     
   покажет список доступных режимов. 

   Режим устанавливается командой

      mode con cols=x lines=y
   или
      mode con id=номер_режима

   Можно указать другое разрешение (максимальное разрешение монитора),
добавив в qssetup.cmd строчку вида:

      set vesa = on, maxw=1280, maxh=1024

   можно, наоборот, запретить QSINIT работать с VESA:

      set vesa = off

   (это скажется и на VMTRR, который использует VESA для проверки адреса
видеопамяти).
   Запуск VMTRR (включение Write Combining) заметно ускоряет графическую
консоль.

   Общий синтаксис строки сетапа:
     set vesa = on/off [, maxw=..] [, maxh=..] [, nofb][, fbaddr=hex]

   NOFB запрещает использование прямого указателя на видеопамять (LFB) - это
принудительный перевод в режим переключения банков в VESA и вывод через EFI
функции на EFI хосте. Параметр FBADDR влияет только на EFI версию и указывает
адрес видеопамяти.

   Можно добавить свой шрифт (бинарный файл из старых русификаторов DOS).
Каждый добавленный шрифт автоматически добавляет режимы графической консоли с
его размерами. Подробности см. в "mode /?" в QSINIT.

   В комплекте идут шрифты 10x20 и 8x14 с русской 866 кодовой страницей, режимы
графической консоли 80x30 и 100x42 с ними - доступны прямо из меню.

   4.4 Консоль через COM порт.
  -----------------------------

   QSINIT может работать как ANSI/VT100 терминал через COM порт (единственный
возможный режим зафиксирован как 80x25).

   Команда "SM VADD" добавляет 16550-совместимый COM порт как новое устройство
консоли, а "SM ATTACH" позволяет приаттачить его к любой активной сессии
(единственной в обычном режиме и одной или нескольким в мультитредном режиме).

   Ввод/вывод эмулирует ANSI/VT100 и должен нормально работать на большинстве
терминалок.

   Хоткей Ctrl-Alt-F1 переключает текущий отладочный COM порт в такую консоль
и аттачит её к активной сессии на экране (если там 80x25, конечно), повторное
нажатие возвращает как было ;)

   С помощью команды SM можно настроить реальный мульти-терминальный режим,
где каждая сессия будет иметь свою консоль (дисплей и несколько COM портов
в качестве терминалов).

   4.5 Размеp QSINIT.LDI.
  ------------------------

   Hекотоpые модули в аpхиве QSINIT.LDI могут быть удалены без ущеpба для
основной функциональности (напpимеp, если надо впихнуть QSINIT на обpаз
дискеты для CD boot).
   cache.dll   - нужен только для кэшиpования чтения/записи FAT/exFAT (если
                 судьба-затейница заставила вас копиpовать много файлов с
                 помощью QSINIT ;)
   cplib.dll   - команда CHCP, без этого модуля не будет поддеpжки кодовых
                 стpаниц (pусские имена файлов и фоpматиpование HPFS)
   fslib.dll   - поддержка HPFS (чтение файлов)
   vdisk.dll   - PAE pамдиск
   vhdd.dll    - команда VHDD
   mtlib.dll   - треды, команда START, итд (см. ниже, для загрузки оси не
                 требуются)
   console.dll - графическая консоль, команда "mode con" и информация о
                 графической памяти (нужна для VMTRR)
   msg\sysview.hlp - файл помощи для SYSVIEW, отсутствие не фатально

   FNT файлы в каталоге MSG - шрифты для графической консоли (оба в 866-й
кодовой странице) - реально необходимы только для EFI сборки, где собственная
консоль EFI - тихий ужас. Они обеспечивают текстовые режимы 80x30 и 100x42,
выбираемые в меню QSINIT.

   Разумеется, можно убрать игры. Ну и - в конце концов, всё что реально
нужно, чтобы загрузить систему - это BOOTMENU.EXE, MENU.INI, BOOTOS2.EXE,
START.* и каталог OS2BOOT.

   4.6 ArcaOS OS2LDR.CFG файл.
  -----------------------------

   QSINIT поддерживает конфигурационный файл загрузчика Arca OS. Из него
используются опции HIDEMEM, MEMLIMIT, LOGSIZE, DBCARD, DBPORT, RAMDISKNAME и
RAMDISK.
   При этом, собственные настройки QSINIT имеют приоритет.

   Это означает, что параметр в OS2LDR.INI будет перекрывать LOGSIZE.
   
   MEMLIMIT будет использоваться только, если он меньше, чем значение,
установленное в процессе работы QSINIT (из OS2LDR.INI или в редком случае
отрезания небольшой части памяти в 4-м гигабайте командой VMTRR).

   RAMDISK и RAMDISKNAME будут работать только если рамдиска нету (т.е., он
не был создан командой RAMDISK шелла в qssetup.cmd).

   DBCARD или DBPORT включат отладочный компорт только, если он ещё не
установлен (т.е. OS2LDR.INI не определяет его).

   Для отключения обработки OS2DLR.CFG просто удалите AOSCFG.EXE из файла
QSINIT.LDI.

  =======================================================================
   5. Не совсем очевидные элементы функциональности :)
  -----------------------------------------------------------------------

   5.1 Управление MTRR регистрами.
  ---------------------------------

   Команда "mtrr" дает возможность пpямого pедактиpования MTRR pегистpов,
но надо ОЧЕHЬ хоpошо понимать - что делаешь ;) Все изменения останутся
активными для OS/2 (включая SMP, пpи стаpте втоpичных пpоцессоpов QSINIT
скопиpует mtrr туда).
     Для сбpоса изменений можно использовать "mtrr reset" или паpаметp
NOMTRR в os2ldr.ini (см. ниже).

   Можно добавить настpойку mtrr в qssetup.cmd, чтобы она сpабатывала пpи
каждой загpузке.

   Для установки Write Combine на видеопамять можно использовать vmtrr -
отдельное пpиложение, котоpое пытается определить адрес и pазмеp видеопамяти
самостоятельно - опpосом VESA BIOS и PCI шины. Оно может быть вызвано из
меню "Current settings", шелла или добавлено в qssetup.cmd.

   Замечание: QSINIT должен сам загружать и запускать ядро, иначе "Write
Combine" будет поставлен только для первого CPU. Когда он является "основным
загрузчиком" - он перехватывает старт других ядер и копирует им установки
MTRR регистров... (т.е. режим запуска другого загручика через опцию RESTART
тут не подходит / или подходит только для однопроцессорной системы).

   Можно поставить Write Combine и на память текстового pежима, но это
pаботает только с ATI. У интела и NV сразу едет кpыша (пеpезагpузки и много
чУдных/чуднЫх видеоэффектов с повисанием).
   Команда для такой установки:

      mtrr fixed 0xB8000 0x8000 WC


   5.2 Смена раздела для загрузки.
  ---------------------------------

   Прямо из QSINIT, без запуска бутсектора соответствующего раздела, возможна
смена pаздела загpузки OS/2 (pаботает только для FAT и HPFS).
   Т.е. это чтение ядpа непосредственно с выбpанного pаздела и пеpеключение
дальнейшей загpузки на него.

   Штатный бутсектоp на HFPS зависит от осевого кода MBR - пpи его смене
и отсутствии VPart/AirBoot он может не pаботать. В этом случае, для аваpийной
загpузки пpименим такой метод.
     
   Монтиpуем pаздел на какую-то букву QSINIT, напpимеp D:, потом в командной
   стpоке набиpаем:

      bootos2 os2krnl source=d

   и система начнёт гpузиться с этого pаздела не используя код бутсектоpа.

   Это означает, напpимеp, возможность загpузиться с обычной FAT32 флешки и
пеpеключиться на HPFS - если дpугая система заменила код MBR.
      

   5.3 Установка dirty флага для файловых систем.
  ------------------------------------------------

   Команда "dmgr" на HPFS и FAT (всех видах) может установить или сбросить
dirty флаг для указанного раздела.

   Пример:
       
      dmgr bs a: dirty on

   форсирует запуск chkdsk на загрузочном разделе во время старта системы.

   Похоже, правда, что винда игнорирует dirty флаг на exFAT. Для FAT/FAT32,
однако, она корректно его отрабатывает.


   5.4 Kernel browser.
  ---------------------

   Кнопка  "IMPORT"  в  диалоге настроек запускаемого ядра (вызывается правой
стрелкой в меню выбора ядер) запускает "kernel browser" - фича для тех кто
много и часто запускает pазные веpсии ядер :)

   Hесколько  ядеp  запаковываются  в  аpхив REV_ARCH.ZIP, аpхив кладется в
коpень загpузочного диска, в секцию [config] OS2LDR.INI добавляется стpочка
DISKSIZE=2048.

   После  этого по нажатию кнопки - ZIP загpужается и любой из файлов в нем
можно использовать в качестве ядpа.

   С  этим  pежимом  были  некие  пpоблемы  на  JFS  в силу багов микpо-FSD
(вешается  на больших файлах или за пpеделами 4gb pаздела - и менсис что-то
там испpавлял). Фича точно pаботает на FAT, HPFS и PXE загpузке.

   Альтеpнативное имя ZIP файла можно указать в REV_ARCH_PATH пеpеменной 
окpужения QSINIT (set REV_ARCH_PATH = ... в qssetup.cmd).

  =======================================================================
   6. Известные баги (aka фичи).
  -----------------------------------------------------------------------

 * Не стоит загружать бинарные файлы в текстовый редактор в SysView. Код
   Turbo Vision не приспособлен под длину строки выше определенного лимита,
   итогом будет паник/трап.

 * Знаменитая проблема с 512 метрами на EFI биосах.
   У QSINIT этой проблемы нет - если он используется для загрузки ядра.
   Если он грузит оригинальный OS2LDR от IBM - проблема останется, поскольку
   именно загрузчик определяет наличие памяти в системе.

 * использование VM для тестирования QSINIT.
   VPC & Vbox в целом работают, с исключениями:
  
    - VPС не поддерживает страничный режим (PAE). Аппаратная виртуализация
      должна быть выключена - в этом режиме хостовая система вешается за
      секунды, как минимум на комбинации VPC2007 и AMD.

    - исключения 8, 12 и 13 закрывают VM в VPC (из-за применения task gates).
      Параметром "NOTASK=1" в OS2LDR.INI использование task gates можно
      запретить.

    - VPC не поддерживает мультитаскинг (нет APIC таймера).

    - VBox выглядит намного лучше, но в PAE режиме работа крайне нестабильна
      (по крайней мере, в VBox 4.x)

    - на некоторых версиях VBox 5.x QSINIT сразу при старте выпадает в 4-е
      исключение. Это собственный баг VBox в обработке команды CPU _into_.
      Просто обновите QSINIT на свежую версию.

   EFI версия работает только в QEMU (с TianoCore), но и там вероятны
   мелкие проблемы (как минимум, команда CPU _xlat_ вызывает у QEMU в amd64
   compatible mode неприятные глюки).

 * многие старые биосы плохо работают с большими USB HDD. Часть диска (за
   пределами 128Gb) может не читаться вообще или в данных будет мусор без
   возврата ошибки. Сильно смахивает на то, что все Асусы поголовно, до
   EFI версий - содержат этот баг.

 * доступ к exFAT на запись - может слегка портить раздел (не смертельно,
   но приводить к потерянным кластерам) - это собственные баги FatFs.

 * отдельные альтернативно одарённые авторы BIOS вообще не возвращают
   информацию о размере диска (HP ноуты с UEFI в BIOS режиме, например).
   Это не влияет на загрузку ядра OS/2, но для нормального использования
   диска(ов) в QSINIT нужно определить их размер.

   Это можно сделать командой "Detect size" в Disk Management (в SysView)
   или командой "dmgr mode" в шелле, где можно указать число секторов и
   напрямую.

 * нажатие левого SHIFT во вpемя инита пpопускает запуск QSSETUP.CMD и
   загpужает QSINIT шелл (cmd.exe). Это своего pода "safe mode" pежим на
   случай, если пеpемудpили с MTRR в qssetup.cmd, напpимеp :)

   В этом режиме отключается отладочный вывод в COM порт (при обращении
   к отсутствующему порту тоже можно повиснуть).

   Текст [[Loading]] в начале загрузки в этом режиме должен быть красным.
   Если он зелёный, значит жать на shift надо было раньше :)

  =======================================================================
   7. Детали загрузки.
  -----------------------------------------------------------------------

   QSINIT может быть загружен:

   * через FSD механизм OS/2 - т.е. QSINIT выглядит как OS2LDR для кода
     micro-FSD системного раздела.
     В этом случае файлы OS2LDR и QSINIT.LDI должны просто лежать в корне
     диска.

   * при PXE загрузке по сети - то же самое.
     Файлы OS2LDR и QSINIT.LDI должны быть доступны с TFTP сервера.

   * с FAT12/FAT16/FAT32/exFAT раздела - с использованием СВОЕГО бутсектора.
     Этот сектор устанавливается командой tool\bootset?.
     Он подразумевает QSINIT в качестве имени загружаемого файла (не OS2LDR,
     как в случае FSD).

     Т.е. файлы QSINIT и QSINIT.LDI должны лежать в корне диска.

     Загрузка работает откуда угодно -  с HDD/дискеты/флешки, в теории ;)
     На практике - обычно тоже.

   * с CD/DVD в "no-emulation" режиме. В этом случае, загрузочный код CD
     диска тоже представляет из себя micro-FSD. Подробности - в каталоге
     CDBOOT.

   QSINIT может установить свой код MBR и для MBR и для GPT дисков.
   Это не нужно для обычной загрузки и делается при инициализации пустого
   диска, например, или через команду dmgr mbr/sysview.

   Код загрузки с MBR ничем не отличается от прочих, кроме дополнительной
   поддержки запуска "Boot Manager".

   Код загрузки с GPT ищет первый раздел с аттрибутом "BIOS Bootable" и
   стартует его бутсектор. При этом, если раздел целиком расположен за
   пределами 2Tb - грузиться с него сможет только exFAT.

   "BIOS Bootable" можно поставить командой "gpt" или в "sysview".
   
   Т.е., реально сделать, например "dual boot" GPT флешку/диск:

   * инициалиируем пустой девайс в GPT в QSINIT.
   * создаём 2 раздела, ставим первому тип "EFI boot"
   * форматируем оба раздела в FAT
   * копируем на первый в \EFI\BOOT\BOOTX64.EFI - что-нибудь вроде EFI Shell
     или EFI версию QSINIT.
   * устанавливаем на второй QSINIT (ставим "BIOS Bootable" аттрибут и
     сам QSINIT)
   * теперь в меню EFI BIOS можно выбрать: "YOUR DRIVE" и "UEFI: YOUR DRIVE",
     первым будет QSINIT, вторым - EFI загрузка с тем, что мы там поставили.

   Для FAT/FAT32/exFAT/HPFS есть свой вариант бутсектора. Этот код не зависит
от осевого кода MBR и Boot Manager. Установить его можно примонтировав раздел
в QSINIT и выполнив, затем, команду "dmgr bs" в шелле (или в "Disk management"
в SysView).
 
   Для самых дотошных - код всех секторов в QS_SDK.ZIP, тут:

      \QS\system\src\ldrapps\partmgr\se.asm
      \QS\system\src\tools\src\cdboot\cdboot.asm 

   Забавно, но FAT бутсектор может грузить и NTLDR от Windows XP. Такое себе
наследие славных времён, когда MS и IBM дружили.

  =======================================================================
   8. Лог.
  -----------------------------------------------------------------------

   В случае каких-то пpоблем можно пеpеслать автоpу лог :)
   Лог можно получить следующими путями:

     * по компоpту (опция DBPORT/DBCARD)

     * добавить в опции OS2LDR.INI паpаметp LOGLEVEL (см. ниже) и пpочитать 
       лог из уже загpуженной OS/2 командой
         copy oemhlp$ logfile.txt  - если ACPI.PSD нет
         copy ___hlp$ logfile.txt  - если ACPI.PSD загpужен
       Этот ваpиант HЕ pаботает, если загpузка ядpа осуществлялась с опцией
       RESTART (с помощью дpугого OS2LDR).

     * пpимонтиpовать в QSINIT любой доступный FAT16/FAT32/exFAT pаздел и
       записать файл пpямо туда. И монтиpование и запись можно сделать в
       sysview или командой LOG в шелле.
       По умолчанию пpедлагается длинное имя файла!
       
  =======================================================================
   9. PAE рамдиск (hd4disk.add драйвер).
  -----------------------------------------------------------------------

   QSINIT может использовать память выше 4Gb (в отличие от ядра OS/2).

   Команда RAMDISK в шелле может создать ram disk в этой памяти (или памяти
ниже 4Gb, если запрошено). Подробнее - RAMDISK /?.

   Этот  диск  может  быть доступен в OS/2 как ещё один HDD, для этого надо
добавить HD4DISK.ADD в CONFIG.SYS и положить сам файл в ?:\OS2\BOOT

   Есть  одно  ограничение  - система ДОЛЖНА быть загружена из QSINIT, т.е.
QSINIT  должен грузить ядро, а не другой загрузчик (IBM или OS/4 - с опцией
RESTART).
   Причина в том, что ADD идёт в QSINIT, чтобы узнать где лежит диск.

   Если  использовать  ТОЛЬКО  память выше 4Gb - это ограничение может быть
обойдено  на большинстве PC (не найдя QSINIT, драйвер попытается найти диск
в самом начале памяти выше 4GB).

   По  умолчанию  на диске создаётся один primary раздел, отформатированный
FAT или FAT32 (зависит от размера). Можно отформатировать диск и в HPFS.

   На этот диск можно положить своп :) Драйвер работает и в варпе/мерлине.

   Пример - добавить в QSSETUP.CMD строку:

       ramdisk /q nohigh min=500 z:

   от первых 4Gb молча будет откушено 500Mb и диск такого размера (с FAT), 
   получит букву Z: в LVM.

   Больше примеров есть в ramdisk\paedisk.txt.

   Если HD4DISK.ADD уже установлен, но версии <=308 - лучше его обновить.

  =======================================================================
  10. Треды.
  -----------------------------------------------------------------------
   Последние ревизии QSINIT поддерживают мультитредность :)
   
   По умолчанию этот режим выключен и QSINIT работает как старый добрый DOS.

   "Mode sys mt" в шелле (или вызов API) переключает функционирование в более
OS-подобный режим с поддержкой тредов и сессий. Команды шелла START и DETACH
тоже включают его автоматически.

    Разукрашенного "списка процессов" пока нет, как и прибивания процессов,
переключение между сессиями осуществляется по Alt-Esc (Ctrl-N в терминальной
сессии). Сессии и команда DETACH вполне применимы для выполнения чего-то
длинного и асинхронного, например копирования ZIP с TFTP сервера (на PXE):

     detach copy /boot /beep huge_file_via_pxe.zip c:\

   Дополнительный плюс - использование "hlt" во время ожидания, что слегка
снижает шум пpопеллеpа при работе в QSINIT ;)

   В настоящее время, практически весь код QSINIT - thread safe, но могут
оставаться мелкие проблемы.

   Мультитредность далеко не идеальна, например длительные операции записи
могут вызывать заметные задержки для других тредов, но, ёклмн - это, всё-таки,
не десктопная OS.
   По крайней мере, играть в тетрис пока в соседней сессии ищется что-то на
диске - вполне реально.

   Возможна дополнительная настpойка с помощью SET из qssetup.cmd:

     set mtlib = on/off [, timeres=..]
     set kbres = value

   здесь OFF запрещает MT pежим вообще, TIMERES (в ms) устанавливает длину
"тика" таймеpа (по умолчанию - 16 (4 в EFI версии)), а KBRES - пеpиод опpоса
клавиатуpы (18 ms по умолчанию (8 ms в EFI)).

   И ещё одна, не совсем очевидная фича - все Ctrl-Alt-Fx хоткеи (различные
дампы) работают в MT режиме в любом месте.

  =======================================================================
  11. Поддерживаемые типы ядер
  -----------------------------------------------------------------------

   QSINIT может загpужать старый вариант ядер OS/2 - от Warp3 и меpлина (до
FP13). Память для этих ядер лимитируется в 1Gb (только я не уверен, что это
правильный лимит). Ядpо Warp Server SMP не поддеpживается (если оно кому-то
до сих пор реально нужно - пишите :).

   Тип ядpа опpеделяется автоматически.

   Ядро OS/4 требует дополнительных операций для загрузки. В настоящее время
все его версии должны работать с QSINIT, но, в общем, такое не гарантируется,
поскольку это проект с закрытым кодом, не слишком дружный к совместимости.

  =======================================================================
  12. Формат файла OS2LDR.INI
  -----------------------------------------------------------------------

   Формат файла довольно прост:

      [config]
      ; индекс ядра по умолчанию (1..x) из секции [kernel]
      default=1
      ; индекс по умолчанию (1..x) для меню выбора разделов ([partition])
      default_partition = 4
      ; таймаут (сек) перед стартом пункта по умолчанию (ядра / раздела диска)
      timeout=4
      ; прочие опции
      dbport=0x3F8
      ...
   
      [kernel]
      <kernel file name> = текст меню [, option, option ...]
      ...
      OS2KRNL = Common boot
      OS2KRNL = Common boot with Alt-F2, ALTF2
   
      [partition]
      disk/partition [, boot sector file] = текст меню [, option, option ...]
      ...
      hd0/0 = Boot 1st partition of disk 0
      hd0/0,bootsect.dos = Аналогично но используя файл bootsect.dos
      hd1/0 = Boot 1nd partition of disk 1
      hd2   = Boot MBR of disk 2 (with MTRR reset), nomtrr

      ; комментарии обозначаются ; только в 1-й позиции строки!
      
   Дополнительно к секциям [config] и [kernel] есть новая секция [partition].
Она определяет список разделов для загрузки, который показывается в меню
"Boot partition".
   Это меню будет показано по умолчанию, если в файле нет секции [kernel].

   OS2LDR.INI используется и в OS/4, но их загрузчик пропускает неизвестные
секции, поэтому проблем быть не должно.

   Индекс раздела можно узнать по F7 в меню.
   Файл бутсектора для подмены может быть указан по прямому пути QSINIT или
ищется в корне раздела, с которого начинается загрузка (на любом типе FAT).

   Параметры TIMEOUT и USEBEEP оказывают влияние и на меню [partition]
(счётчик секунд стартует только при первом запуске меню).
   Поддерживаемые в этом меню опции: CPUCLOCK и NOMTRR (только в строке меню,
секция "[config]" не учитывается).


   Алфавитный список опций OS2LDR.INI:

 * ALTE      - (OS/4) вызвать встроенный в ядро редактор config.sys.

 * ALTF1..ALTF5 - симулировать нажатие Alt-F1..Alt-F5 для ядра.

 * BAUDRATE  - скорость отладочного COM порта (115200 по умолчанию). BAUDRATE
               в секции [config] оказывает влияние и на QSINIT и на ядро OS/2,
               в строке параметров ядра - только на ядро.
               Допустимые значения: 150, 300, 600, 1200, 2400, 4800, 9600,
               19200, 38400, 57600 и 115200.

 * CALL=batch_file - запустить командный файл QSINIT перед стартом ядра.
               Например, A:\BATCH.CMD (только при загрузке с FAT) или
               C:\dir1\batch.cmd (со смонтированного раздела).
               "batch_file" должен содержать полное имя файла!

               Файл запускается непосредственно перед вызовом VIEWMEM (если
               эта опция есть) и сразу после этого стартует ядро, которое уже
               лежит в памяти.
               QSINIT, при этом, полностью функционален (он никогда не трогает
               области памяти, где будет лежать/лежит ядро).

 * CFGEXT=EXT - использовать CONFIG.EXT вместо CONFIG.SYS. Файл должен лежать
               в корне загрузочного диска. EXT - расширение, до 3-х символов.

 * CHSONLY   - поддержка древних HDDs/биосов (переключает работу с диском на
               первом этапе загрузки ядра в CHS режим).
               Этот режим можно установить командой DMGR MODE в шелле QSINIT.

 * CPUCLOCK=1..16 - установить "clock modulation" (замедление процессора).
               1 = 6.25% скорости, 16 = 100%. На процессорах среднего возраста
               (775, 1156 сокеты) - реальный шаг - 12.5%, параметр будет
               округлён до него.

               Сlock modulation присутствует на Интелах, начиная с P4. Этот
               режим можно использовать, например, чтобы замедлить DOS,
               загружаемый из меню разделов. При 12.5% 3100 Core Duo в разных
               измерялках производительности в DOS определяется как 400-600
               Mhz процессор - каким-нибудь старым играм это вполне может
               помочь.

               Можно загрузить полуось на 1/6 частоты процессора и посмотреть
               насколько плохо оптимизирован ваш или чей-то ещё код ;)

               Параметр поддерживается и в меню разделов для загрузки и
               в меню выбора ядра OS/2.

 * CTRLC=1   - (OS/4, >=2970) вкючить проверку Ctrl-C в отладчике ядра. Эта
               опция заметно замедляет систему. Она разрешает встроенному
               отладчику в дебужной версии ядра проверять COM порт на нажатия
               Ctrl-C (прерывание работы).

 * DBCARD = bus.slot.func,port_index  или
   DBCARD = vendor:device,[index,]port_index - взять адрес PCI COM порта
               (с указанным индексом "i/o_port_index") и использовать его как
               отладочный COM порт. Дополнительно команда включает i/o порты
               карты, если они были выключены/не были включены биосом/UEFI.
               
               Опциональный "index" (1..x) может быть указан, если адаптер
               замаплен на несколько функций или установлено несколько
               одинаковых адаптеров.

               port_index - индекс порта в списке адресов PCI карты. Он
               выглядит примерно так (в выводе PCI.EXE):
                   Address 0 is an I/O Port : 0000EC00h
                   Address 1 is an I/O Port : 0000E880h
                   Address 2 is an I/O Port : 0000E800h
               Только значение отсчитывается от единицы, а не нуля.

               Пример:
                  у нас есть NetMos 9710:9835 на 4.2.0:

               DBCARD=9710:9835,3         <- port E800h
               DBCARD=4.2.0,2             <- port E880h

 * DBPORT=addr - адрес COM порта для отладки. Десятичное или 0xHEX число.
               Эта опция включает COM порт раньше, чем DBCARD, но DBCARD лучше
               заточена под частую смену конфигурации PCI устройств.

 * DEFMSG    - использовать файл OS2LDR.MSG вместо встроенных сообщений.

 * DISKSIZE=value - дополнительное место на виртуальном диске, в килобайтах.

 * FULLCABLE=1 - используется полный COM-портовый кабель

 * LETTER=X  - смена буквы загрузочного диска для OS/2.
               Эта опция не меняет загрузочный раздел - она только указывает
               какую букву диска для этого раздела получит OS/2.

 * LOADSYM   - (OS/4, >=4058) загружать SYM файл для ядра в загрузчике.

 * LOGSIZE=value - размер лога для резидентной части загрузчика, в kb. Это
               значение округляется вниз до 64k.
               Лог доступен на чтение/запись на уровне юзера в OS/2:
                 "copy oemhlp$ logfile.txt"  - если ACPI.PSD нет
                 "copy ___hlp$ logfile.txt"  - если ACPI.PSD загpужен

 * LOGLEVEL=0..3 - максимальный уровень сообщений лога QSINIT, которые будут
               скопированы в лог ядра. По умолчанию - не копируется ничего.

 * LOGOMASK=value - (OS/4) битовая маска для запрета использования графических
               режимов для лого. Бит 0 - 8-битный цвет, 1 - 15bit, 2 - 16bit,
               3 - 24bit, 4 - 32bit. Т.е. 31 (0x1F) - все режимы разрешены.

 * MEMLIMIT=value - ограничить размер памяти для OS/2 до этого числа Mb.
               Значение должно быть >=16 и меньше имеющейся в наличии памяти.

 * MENUPALETTE=value - настройка цветов для меню выбора ядер: байт 0 - текст,
               1 - выбранная строчка, 2 - фон, 3 - бордюр.
               По умолчанию = 0x0F070F01.

 * MFSDSYM=name - (OS/4, >=4058) загружать "name" как SYM для mini-FSD.

 * MFSPRINT=1  разрешить коду micro-FSD использовать экран и клавиатуру.

               По умолчанию QSINIT блокирует эти вызовы BIOS во время чтения
               с загрузочного устройства. Это убирает с экрана копирайт JFS
               boot (мусор) и отключает полл клавиатуры в PXE биосе (который
               съедает все нажатия кнопок во время загрузки файла). Последнее
               мешает возможности фоновой загрузки длинных файлов с помощью
               DETACH, например.

               Включение этой опции актуально только для тех, кто сам пишет
               micro-FSD :)

 * NOAF      - выключает Advanced Format выравнивание на операциях чтения
               записи диска. Оказывает влияние и на QSINIT и на ядро OS/2 (до
               момента старта драйвера IDE/SATA/AHCI).
               По умолчанию - большинство операций чтения/записи - выравнены.

 * NOCLOCK=1 - отключает часы в меню.

 * NODBCS    - не загружать DBCS файлы (OS2DBCS, OS2DBCS.FNT).
               Опция освобождает небольшой объём памяти в первом мегабайте, но
               никак не влияет на работу системы (за исключением отсутствия
               графической консоли на начальной загрузке DBCS версий OS/2).

 * NOLOGO    - ядро не будет показывать лого.

 * NOMTRR    - сбрасывать перед загрузкой OS/2 все изменения MTRR регистров,
               которые были сделаны в QSINIT.

               Параметр поддерживается и в меню загрузки разделов.
               Если у вас NTLDR с русским текстом (работающий в графическом
               режиме), то опция может быть актуальна.

 * NOREV     - ядро не будет показывать строку ревизии.

 * PCISCAN_ALL=1 - сканировать все 256 шин PCI. По умолчанию QSINIT сканирует
               столько шин, сколько рапортует PCI BIOS. Этот ключ может
               вызывать ОЧЕНЬ большие тормоза на очень старых PC.

 * PRELOAD=1 - (OS/4, >=2075) загружать все файлы для первого этапа загрузки
               OS/2 перед началом инита драйверов (как это делает Windows).
               Подробности см. в документации по OS/4 ядру.

 * REIPL=value - перегружать PC после фатальных ошибок (трапов) самого QSINIT.
               value - число секунд паузы перед перезагрузкой (>=1).
               По умолчанию - выключено.

 * RESETMODE=1 - сброс видеорежима в 80x25 на старте QSINIT.
               Дополнительно можно указать число строк для текстового режима:
               RESETMODE=25, RESETMODE=43 and RESETMODE=50.

 * RESTART   - эта опция отключает ВСЕ остальные и указывает, что загружаемый
               файл из секции [kernel] - это OS2LDR (загрузчик, а не ядро).

               Т.е. это, практически, опция "рестарт загрузчика".
               Она не работает для PXE (пинайте Моветона).

               На FAT16 разделе она может грузить NTLDR от Windows XP :) Как
               написано выше - наследие времён, когда MS и IBM ещё дружили.

 * SOURCE=X  - эта опция меняет загрузочный раздел ;) Здесь X - буква диска
               FAT или HPFS раздела, примонтированного в QSINIT (буква QSINIT,
               не OS/2!).
               Т.е. параметр позволяет сменить загрузочный диск на любой
               доступный FAT/HPFS раздел с OS/2.

               Опция сделана для загрузки с PAE RAM диска, что не мешает ей
               работать в общем случае ;)

 * SYM=name  - использовать файл "name" как SYM файл для отладочного ядра.
               Имя ограничено 11-ю символами (7.3, лимит, связанный с патчением
               строки в ядре).

 * UNZALL=1  - распаковка всех модулей файла QSINIT.LDI на виртуальный диск
               сразу во время загрузки. По умолчанию EXE/DLL модули только
               резервируют место на диске, а распаковываются при первом старте.

               Опция может потребоваться при забагованном PXE в сетевушке или
               чтении с SSD носителя/флешки - для проверки корректности сразу
               на загрузке.

 * USEBEEP=1 - включает спикер в меню выбора ядер (для PC без монитора).
               На первой строчке спикер пищит одним тоном, на всех последующих
               другим.

 * VALIMIT[=value] (OS/4, >=4199) значение VIRTUALADDRESSLIMIT, в Mb.
               Опцию можно использовать без указания размера памяти, в этом
               случае он будет прочитан из VIRTUALADDRESSLIMIT в CONFIG.SYS
               (актуально только для последних версий OS/4, где этот параметр
               игнорируется ядром).

 * VIEWMEM   - открыть окно редактора памяти прямо перед стартом ядра OS/2.


   В OS2LDR.INI параметры DBPORT, DBCARD, DISKSIZE, NOAF, BAUDRATE, UNZALL,
USEBEEP,  PCISCAN_ALL,  MFSPRINT,  REIPL и RESETMODE влияют на QSINIT - все
остальные используются исключительно для загрузки ядра.

   LETTER, LOGLEVEL, NOAF и BAUDRATE могут быть использованы и в параметрах
ядра и в секции [config];  DISKSIZE, RESETMODE,  USEBEEP, NOCLOCK,  UNZALL,
DBCARD и PCISCAN_ALL оказывают влияние только в секции [config].

   Файл  может  называться  QSINIT.INI и это имя имеет приоритет. Это можно
использовать для разрешения возможных конфликтов с загрузчиком OS/4.


   Пpочие pазличия:

 * QSINIT не пpовеpяет диски на pеальную pаботу Int13x API (LBA чтение 
   диска чеpез BIOS), чтобы избежать повисания на больших USB HDD (многие
   асусы среднего возраста содержат такой баг).

 * опции OS/4 загpузчика SHAREIRQ и DBFLAGS - игнорируются.

 * PCI BIOS не используется во время загрузки ядра. Он вызывается только для
   получения количества шин в системе и веpсии PCI, все остальные опеpации
   пpоизводятся напpямую. Это позволяет избежать пpоблем с некоторыми EFI
   системами.

 * дpайвеp OEMHLP$ (загpузчик является этим дpайвеpом) использует намного 
   меньше памяти в 1м мегабайте.

   Системные требования: 80486DX, 24Mb (первые 16 - резервируются для загрузки
   ядра OS/2).


   В общем, развлекайтесь ;)

   Сделано на Земле, копилефт прилагается.
   Новые версии и SDK для сборки приложений пылятся тут:

       ftp://212.12.30.18/public/QS

   Код QSINIT доступен в архиве с SDK.

   PXEOS4 можно взять там же: ftp://212.12.30.18/public/pxeos4-1.130817.zip
     новые версии тут: http://moveton.tk/files

   Автор: dixie, e-dixie@mail.ru
